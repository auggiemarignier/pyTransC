"""Functions for obtaining samples from an ensemble."""

import emcee
import numpy as np

from ..exceptions import InputError


def get_transc_samples(
    alg: str,
    n_states: int,
    n_dims: list[int],
    n_samples: list[int] | None = None,  # number of samples in each state
    state_chain: np.ndarray | None = None,
    model_chain: np.ndarray | None = None,
    relative_marginal_likelihoods: np.ndarray | None = None,
    product_space_sampler: emcee.EnsembleSampler | None = None,
    ntd_samples=1000,
    discard=0,
    thin=1,
    ensemble_per_state=None,
    flat=False,
):  # generate a trans-c ensemble from either TransC-ens or TransC-ps samplers
    """
    Utility routine to retrieve list of trans-C model space samples, previously calculated by either run_is_ensemble_resampler(),run_product_space_sampler() or run_ens_mcint() or run_state_jump_sampler.

    For algorithms TransC-ensemble-resampler and TransC-integration the input variable 'ntd_samples' determines the number of trans-C model space samples generated and then returned.
    For algorithms TransC-product-space and TransC-state-jump-sampler the number of trans-C model space samples is determined by the original sampler and modified by chain thinning (see `discard` and `thin` parameters).

    Inputs:
    ntd_samples - int           : number of trans-C samples to generate [for alg 'TransC-integration' or 'TransC-ensemble-resampler'].
    discard - int               : number of output samples to discard, also known as `burnin' (default = 0)) [only relevant if alg = 'TransC-product-space' or 'TransC-state-jump-sampler'].
    thin - int                  : frequency of output samples in output chains to accept (default = 1, i.e. all) [only relevant if alg = 'TransC-product-space' or 'TransC-state-jump-sampler'].
    verbose - bool              : switch to print some diagnostic info to standard out.


    Returns:
    transc_ensemble - list      : list of trans-C samples ordered by state.
                                    if flat=True, format is [state,i],i=1,...,n(state); where n(state) is the number of models generated in state i.
                                    otherwise format is [state,walker,i], where samples are also separated by their walker.
                                    if alg is `TransC-product-space` or `TransC-state-jump-sampler` size of ensemble returned depends on values of discard and flat.
                                    if alg is `TransC-ensemble-resampler` or `TransC-integration`,  size of ensemble returned is given by ntd_samples.
    model_chain - floats        : list of trans-C samples. For ensemble generated by `run_product_space_sampler`, number determined by
                                    discard and thin.
    states_chain - ints. : list of states of trans-C samples.

    """

    if (
        alg == "TransC-ensemble-resampler" or alg == "TransC-integration"
    ):  # draw random trans-C models according to relative marginals for TransC-ens resampler
        if ensemble_per_state is None:
            raise InputError(
                "For TransC-ensemble-resampler or TransC-integration, ensemble_per_state must be provided."
            )
        if relative_marginal_likelihoods is None:
            raise InputError(
                "For TransC-ensemble-resampler or TransC-integration, relative_marginal_likelihoods must be provided."
            )
        return _get_transc_samples_given_ensemble_per_state(
            n_states,
            n_samples,
            relative_marginal_likelihoods,
            ensemble_per_state,
            ntd_samples=ntd_samples,
        )

    elif (
        alg == "TransC-product-space"
    ):  # build trans-C model ensemble from product space chains for TransC resampler
        if product_space_sampler is None:
            raise InputError(
                "For TransC-product-space, product_space_sampler must be provided."
            )
        return _get_transc_samples_given_product_space_sampler(
            product_space_sampler,
            n_states,
            n_dims,
            discard=discard,
            thin=thin,
            flat=flat,
        )

    elif (
        alg == "TransC-state-jump-sampler"
    ):  # build trans-C model ensemble from product space chains for TransC-state-jump-sampler
        if state_chain is None or model_chain is None:
            raise InputError(
                "For TransC-state-jump-sampler, state_chain and model_chain must be provided."
            )
        return _get_transc_samples_given_chains(
            state_chain,
            model_chain,
            n_states,
            discard=discard,
            thin=thin,
            flat=flat,
        )


def _get_transc_samples_given_ensemble_per_state(
    n_states: int,
    n_samples: list[int],  # number of samples in each state
    relative_marginal_likelihoods: np.ndarray,
    ensemble_per_state: list[np.ndarray],
    ntd_samples: int = 1000,
):
    rng = np.random.default_rng()
    states_chain = rng.choice(
        n_states, size=ntd_samples, p=relative_marginal_likelihoods
    )

    model_chain = ntd_samples * [None]
    for i in range(
        ntd_samples
    ):  # randomly select models from input state ensembles using evidence weights
        j = rng.choice(n_samples[states_chain[i]])
        model_chain[i] = ensemble_per_state[states_chain[i]][j]

    transc_ensemble = []  # create transc ensemble of models ordered by states for a single walker
    for i in range(n_states):
        ind = [num for num, n in enumerate(states_chain) if n == i]
        transc_ensemble.append(np.array([model_chain[j] for j in ind]))
    return transc_ensemble, model_chain, states_chain


def _get_transc_samples_given_product_space_sampler(
    product_space_sampler: emcee.EnsembleSampler,
    n_states: int,
    n_dims: list[int],
    discard: int = 0,
    thin: int = 1,
    flat: bool = False,
):
    samples = product_space_sampler.get_chain(
        discard=discard, thin=thin, flat=flat
    )  # collect model ensemble
    if samples is None:
        raise ValueError("No samples found in the product space sampler chain.")

    ind1 = np.cumsum(n_dims) + 1
    ind0 = np.append(np.array([1]), ind1)

    transc_ensemble = []  # create transc ensemble of models ordered by states

    if flat:  # combine walkers
        state_chain = np.rint(samples[:, 0]).astype("int")
        model_chain = []
        n_steps = np.shape(state_chain)[0]
        for i in range(n_steps):
            model_chain.append(samples[i, ind0[state_chain[i]] : ind1[state_chain[i]]])

        for i in range(n_states):
            ind = [num for num, n in enumerate(state_chain) if n == i]
            transc_ensemble.append(np.array([model_chain[j] for j in ind]))
    else:  # separate ensemble by walkers
        state_chain = np.rint(samples[:, :, 0]).astype("int")
        n_steps, n_walkers = np.shape(state_chain)
        model_chain = []
        for i in range(n_steps):
            m = []
            for j in range(n_walkers):
                m.append(
                    samples[
                        i,
                        j,
                        ind0[state_chain[i, j]] : ind1[state_chain[i, j]],
                    ]
                )
            model_chain.append(m)

        st = np.transpose(state_chain)
        n_walkers = np.shape(state_chain)[1]
        for i in range(n_states):
            t = []
            for k in range(n_walkers):
                ind = [num for num, n in enumerate(st[k]) if n == i]
                t.append(np.array([model_chain[j][k] for j in ind]))
            transc_ensemble.append(t)

    return transc_ensemble, model_chain, state_chain


def _get_transc_samples_given_chains(
    state_chain: np.ndarray,
    model_chain: np.ndarray,
    n_states: int,
    discard: int = 0,
    thin: int = 1,
    flat: bool = False,
):
    models_chain = [row[discard::thin] for row in model_chain]  # stride the list
    states_chain = state_chain[discard::thin, :]  # stride the array

    transc_ensemble = []  # create transc ensemble of models ordered by states
    n_steps, n_walkers = np.shape(states_chain)
    a = np.transpose(states_chain)

    for i in range(n_states):
        t = []
        for k in range(n_walkers):
            ind = [num for num, n in enumerate(a[k]) if n == i]
            t.append([models_chain[k][j] for j in ind])
        if flat:  # combine walkers
            transc_ensemble.append(_flatten_extend(t))
        else:  # separate ensemble by walkers
            transc_ensemble.append(t)

    return transc_ensemble, models_chain, states_chain


def _flatten_extend(matrix):
    flat_list = []
    for row in matrix:
        flat_list.extend(row)
    return np.array(flat_list)
